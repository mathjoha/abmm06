---
title: "Interaktiv sannolikhet"
subtitle: "Utforska slump och sannolikhetsteori"
citation:
  type: document
  title: "Sannolikhet - Interaktiv visualisering"
  container-title: "ABMM06: Kvantitativa metoder"
  publisher: Lunds universitet
  license: "CC-BY-NC 4.0"
  url: https://mathjoha.github.io/abmm06/dashboards/sannolikhet-viz.html
format:
  html:
    page-layout: full
    toc: true
---

## Stora talens lag

Se hur frekvensen närmar sig det förväntade värdet när antalet försök ökar.

```{ojs}
//| echo: false

viewof numFlips = Inputs.range([10, 1000], {
  label: "Antal myntkast:",
  step: 10,
  value: 100
})

viewof runSimulation = Inputs.button("Kasta mynt")
```

```{ojs}
//| echo: false

coinFlips = {
  runSimulation;
  const flips = [];
  let heads = 0;
  for (let i = 1; i <= numFlips; i++) {
    if (Math.random() < 0.5) heads++;
    flips.push({
      trial: i,
      proportion: heads / i,
      heads: heads,
      tails: i - heads
    });
  }
  return flips;
}
```

```{ojs}
//| echo: false

Plot.plot({
  width: 700,
  height: 400,
  y: {
    domain: [0, 1],
    label: "Andel krona"
  },
  x: {
    label: "Antal kast"
  },
  marks: [
    Plot.ruleY([0.5], {stroke: "red", strokeDasharray: "4,4"}),
    Plot.line(coinFlips, {x: "trial", y: "proportion", stroke: "steelblue", strokeWidth: 2}),
    Plot.text([[numFlips * 0.8, 0.52]], {text: ["Förväntat värde (0.5)"], fill: "red"})
  ]
})
```

```{ojs}
//| echo: false

md`**Resultat efter ${numFlips} kast:**
- Krona: ${coinFlips[coinFlips.length-1].heads} (${(coinFlips[coinFlips.length-1].proportion * 100).toFixed(1)}%)
- Klave: ${coinFlips[coinFlips.length-1].tails} (${((1 - coinFlips[coinFlips.length-1].proportion) * 100).toFixed(1)}%)

*Öka antalet kast för att se hur andelen närmar sig 50%*`
```

---

## Tärningskast

Simulera tärningskast och se fördelningen.

```{ojs}
//| echo: false

viewof numDice = Inputs.range([10, 500], {
  label: "Antal tärningskast:",
  step: 10,
  value: 100
})

viewof rollDice = Inputs.button("Kasta tärning")
```

```{ojs}
//| echo: false

diceRolls = {
  rollDice;
  const counts = [0, 0, 0, 0, 0, 0];
  for (let i = 0; i < numDice; i++) {
    const roll = Math.floor(Math.random() * 6);
    counts[roll]++;
  }
  return [1, 2, 3, 4, 5, 6].map((value, i) => ({
    value: value,
    count: counts[i],
    proportion: counts[i] / numDice,
    expected: 1/6
  }));
}
```

```{ojs}
//| echo: false

Plot.plot({
  width: 600,
  height: 350,
  x: {
    label: "Tärningsvärde",
    domain: [1, 2, 3, 4, 5, 6]
  },
  y: {
    label: "Andel",
    domain: [0, Math.max(0.3, d3.max(diceRolls, d => d.proportion))]
  },
  marks: [
    Plot.barY(diceRolls, {x: "value", y: "proportion", fill: "steelblue"}),
    Plot.ruleY([1/6], {stroke: "red", strokeDasharray: "4,4"}),
    Plot.text([[4, 1/6 + 0.02]], {text: ["Förväntat (16.7%)"], fill: "red"})
  ]
})
```

---

## Normalfördelningen

Utforska hur medelvärde och standardavvikelse påverkar normalfördelningen.

```{ojs}
//| echo: false

viewof mean = Inputs.range([-10, 10], {
  label: "Medelvärde (μ):",
  step: 0.5,
  value: 0
})

viewof stdDev = Inputs.range([0.5, 5], {
  label: "Standardavvikelse (σ):",
  step: 0.25,
  value: 1
})
```

```{ojs}
//| echo: false

normalData = {
  const data = [];
  for (let x = mean - 4 * stdDev; x <= mean + 4 * stdDev; x += 0.1) {
    const y = (1 / (stdDev * Math.sqrt(2 * Math.PI))) *
              Math.exp(-0.5 * Math.pow((x - mean) / stdDev, 2));
    data.push({x, y});
  }
  return data;
}

// Areas for highlighting
areaData = {
  return {
    oneStd: normalData.filter(d => d.x >= mean - stdDev && d.x <= mean + stdDev),
    twoStd: normalData.filter(d => d.x >= mean - 2*stdDev && d.x <= mean + 2*stdDev)
  };
}
```

```{ojs}
//| echo: false

Plot.plot({
  width: 700,
  height: 400,
  x: {
    label: "Värde",
    domain: [mean - 4 * stdDev, mean + 4 * stdDev]
  },
  y: {
    label: "Täthet"
  },
  marks: [
    Plot.areaY(areaData.twoStd, {x: "x", y: "y", fill: "#cce5ff", fillOpacity: 0.5}),
    Plot.areaY(areaData.oneStd, {x: "x", y: "y", fill: "#99ccff", fillOpacity: 0.7}),
    Plot.line(normalData, {x: "x", y: "y", stroke: "steelblue", strokeWidth: 2}),
    Plot.ruleX([mean], {stroke: "red", strokeWidth: 2}),
    Plot.ruleX([mean - stdDev, mean + stdDev], {stroke: "orange", strokeDasharray: "4,4"}),
    Plot.ruleX([mean - 2*stdDev, mean + 2*stdDev], {stroke: "green", strokeDasharray: "4,4"})
  ]
})
```

```{ojs}
//| echo: false

md`**Fördelningsegenskaper:**
- <span style="color: red">■</span> Medelvärde (μ) = ${mean}
- <span style="color: orange">■</span> ±1σ (68% av data): [${(mean - stdDev).toFixed(1)}, ${(mean + stdDev).toFixed(1)}]
- <span style="color: green">■</span> ±2σ (95% av data): [${(mean - 2*stdDev).toFixed(1)}, ${(mean + 2*stdDev).toFixed(1)}]`
```

---

## Konfidensintervall

Se hur urvalsstorlek påverkar konfidensintervallets bredd.

```{ojs}
//| echo: false

viewof sampleSize = Inputs.range([10, 200], {
  label: "Urvalsstorlek (n):",
  step: 5,
  value: 30
})

viewof trueMean = Inputs.range([40, 60], {
  label: "Sant populationsmedelvärde:",
  step: 1,
  value: 50
})

viewof trueStd = Inputs.range([5, 20], {
  label: "Populationens standardavvikelse:",
  step: 1,
  value: 10
})

viewof takeSample = Inputs.button("Ta nytt urval")
```

```{ojs}
//| echo: false

sampleData = {
  takeSample;
  const samples = [];
  let sum = 0;
  for (let i = 0; i < sampleSize; i++) {
    // Box-Muller transform for normal distribution
    const u1 = Math.random();
    const u2 = Math.random();
    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
    const value = trueMean + trueStd * z;
    samples.push(value);
    sum += value;
  }

  const sampleMean = sum / sampleSize;
  const sampleVariance = samples.reduce((acc, val) => acc + Math.pow(val - sampleMean, 2), 0) / (sampleSize - 1);
  const sampleStd = Math.sqrt(sampleVariance);
  const standardError = sampleStd / Math.sqrt(sampleSize);
  const marginOfError = 1.96 * standardError;

  return {
    samples,
    mean: sampleMean,
    std: sampleStd,
    se: standardError,
    ci_lower: sampleMean - marginOfError,
    ci_upper: sampleMean + marginOfError,
    contains_true: trueMean >= sampleMean - marginOfError && trueMean <= sampleMean + marginOfError
  };
}
```

```{ojs}
//| echo: false

md`**Urvalsstatistik:**
- Urvalsmedelvärde: ${sampleData.mean.toFixed(2)}
- Urvalets standardavvikelse: ${sampleData.std.toFixed(2)}
- Standardfel: ${sampleData.se.toFixed(2)}

**95% konfidensintervall:** [${sampleData.ci_lower.toFixed(2)}, ${sampleData.ci_upper.toFixed(2)}]

${sampleData.contains_true ?
  "✅ Intervallet innehåller det sanna medelvärdet (" + trueMean + ")" :
  "❌ Intervallet missar det sanna medelvärdet (" + trueMean + ")"}`
```

```{ojs}
//| echo: false

Plot.plot({
  width: 600,
  height: 100,
  x: {
    domain: [trueMean - 3 * trueStd / Math.sqrt(10), trueMean + 3 * trueStd / Math.sqrt(10)],
    label: "Värde"
  },
  y: {
    axis: null
  },
  marks: [
    Plot.ruleX([trueMean], {stroke: "red", strokeWidth: 3}),
    Plot.ruleX([sampleData.ci_lower, sampleData.ci_upper], {stroke: "steelblue", strokeWidth: 2}),
    Plot.link([{x1: sampleData.ci_lower, x2: sampleData.ci_upper, y: 0}], {
      x1: "x1", x2: "x2", y1: "y", y2: "y", stroke: "steelblue", strokeWidth: 4
    }),
    Plot.dot([{x: sampleData.mean, y: 0}], {x: "x", y: "y", fill: "steelblue", r: 6}),
    Plot.text([[trueMean, 0.3]], {text: ["Sant μ"], fill: "red"})
  ]
})
```

*Ta flera urval och se att ca 95% av konfidensintervallen innehåller det sanna medelvärdet!*
